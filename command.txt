Command:

Virtualbox must be installed before minikube can start
Start the minikube for local
> minikube start
> minikube delete
> minikube status
> minikube start --driver=virtualbox
after the minikube is started, you can call the dashboard by
> minikube dashboard


Kube yaml file must have
1. apiVersion; 2. Kind; 3. metadata; 4. spec 
Yaml file indent can be by any number of spaces. 
It will work as long as it is indented in the same level. 
kubectl create -f <xxx.yml> (this will execute the yaml file in default namespace)

IMPORTANT!!!!!!!!
Reference Link:
https://kubernetes.io/docs/reference/kubectl/conventions/
The fastest way to generate a YAML TEMPLATE file
>kubectl create deployment --image=nginx nginx --replicas=4 --dry-run=client -o yaml > nginx-deployment.yaml




check all the existing pods, services, replicaset, deployment
> kubectl get all

create pods with nginx
> kubectl run nginx --image=nginx

Check Pods Details
> kubectl get pods (kubectl get pod)
> kubectl get pods -o wide
> kubectl describe pod <pod-name>
  
delete pods
> kubectl delete pod <pod-name>
  
Update Pods
Update the pod-definition file and use 'kubectl apply' command or use 'kubectl edit pod <pod-name>' command.
  
GET / PUT / POST / DELETE is equivalence to get / edit / run /delete in k8s  
  

Get Number of Nodes
> kubectl get nodes
> kubectl get nodes -o wide (show more details)


Check ReplicaSet
> kubectl get replicaset
> kubectl get rs
> kubectl describe replicaset <replicaset-name>
> kubectl describe pods (use to check error on creating the replicaset)

Delete ReplicaSet
> kubectl delete replicaset <replicaset-name>

Edit ReplicaSet; it will be automatically become effective after the file is edited and saved 
> kubectl edit replicaset <replica-set-name>

Scale (you can use kubectl edit rs <rs-name> to update the replicaset OR using the following command; they achievce the same goal)
> kubectl replace -f replicaset-definition.yml
> kubectl scale --replicas=6 -f replicaset-definition.yml
> kubectl scale --replicas=6 <type> <name> 
> kubectl scale --replicas=6 replicaset myapp-replicaset





Namespace

Namespace = House Mark Smith / Mark Williams; 
inside Smith's Home, you just call Mark then it automatically refer to Mark Smith. 
To call Mark Williams in Smith's Home, you need to call Mark Williams

There is a Default, kube-system, kube-public namespace
Or you can crate a Prod or Dev namespace 

The following is the example of DNS used in K8s
db-service.dev.svc.cluster.local
cluster.local is the default domain name used in k8s
svc is the service
dev is the name space
Db-service is the service name
If inside the same namespace, you can simply call "db-service"

> kubectl get namespace
> kubectl get pods --all-namespaces

> kubectl get pods (just get the pods in the default namespace)
> kubectl get pods --namespace=kube-system (specify the pods in other namespace)

> kubectl run redis --image=redis -n finance (create a redis image in namespace finance)

> kubectl create -f xxx.yml (create pod in default namespace)
> kubectl create -f xxx.yml --namespace=dev (create pod in dev namespace)
Or you can specify the namespace in the yaml file under "metadata: namespace:"







Deployment (allow rollout, rollback, pause, start)
> kubectl create -f deployment-definition.yml
> kubectl get deployments
you may also need to run the following; because deployment may create replicaset and pod
> kubectl get replicaset
> kubectl get pods
if you have a replicaset and deployment yml file, deployment will override replicaset
that's if you update the replicaset to 6 but the deployment is set to 1
then it will finally become 1, (that's you set replicaset to 6, but deployment will force it back to 1)
> kubectl scale --replicas=6 deployment/nginx
ususally deployment include replica set; replica set include pod (deployment > replica > pod)



Rollout
> kubectl rollout status deployment/my-app-deployment 
> kubectl rollout history deployment/my-app-deployment
deployment/my-app-deployment => type/deployment-name
 
Rollback
> kubectl rollout undo deployment/my-app-deployment


The following create a deployment with the name httpd-frontend, with image=httpd:2.4-alpine
then set the replicaset as 3
> kubectl create deployment httpd-frontend --image=httpd:2.4-alpine
> kubectl scale deployment --replicas=3 httpd-frontend


Apply a YAML file (this will create/update the config)
> kubectl apply -f <yaml file name>
assume you have a deployment with name "myapp-deployment" and you want to update the nginx image version from 1.7.1 to 1.9.1
> kubectl set image deployment/my-app-deployment nginx=nginx:1.9.1
after the above command, you can use the "> kubectl rollout history deployment/<name>" to check the rollout status (about the deployment)
or you can use "> kubectl rollout undo deployment/<name>" to roll back to the previous version


Check point Summary
Create:
> kubectl create -f deployment-definition.yml
Get:
> kubectl get deployments
Update:
> kubectl apply -f deployment-definition.yml
> kubectl set image deployment/myapp-deployment nginx=nginx:1.9.1
Status:
> kubectl rollout status deployment/myapp-deployment
> kubectl rollout history deployment/myapp-deployment
Rollback:
> kubectl rollout undo deployment/myapp-deployment




Service (enable to communicate between difference components, service help to connect application together)
you can get the IP address of the kubernetes node by: (the internal private address is 10.244.0.0 and all pods are attached to it)
> kubectl get service

Service Type:
NodePort: service makes an internal POD accessible on a Port on the Node (use to listen to a port on the Node and forward reques on that port to a port on the POD running the web appliation.)
ClusterIP: the service creates a virtual IP inside the cluster to enable communication between different services such as a set of front-end servers to a set of backend servers.(group PODs together and provide a single interface to access the PODs in a group. eg. group of backend pods; the requests are forwarded to one of the PODs under the service randomly)
LoadBalancer: load balancer for the services
Summary: For a system, we will use the load balancer as the frist layer. Then we use NodePort to export the internal pods to load balancer. For internal pods, we use ClusterIP to connect them together.

TargetPort = Port in the Pod
Port = Port in the Service
NodePort = Port in Node (30000 - 32767)
Node <-> Service <-> Pod (Service connect the Node and Pod together)

create a service yaml file, use selector and label to connect the pod (detail refer to the example in /Service)

> kubectl describe service <service-name>
Create a service yaml file with name simple-webapp-deployment, with name web-service then map the port
> kubectl expose deployment simple-webapp-deployment --name=web-service --target-port=8080 --type=NodePort --port=8080 --dry-run=client -o yaml > svc.yaml


Accessing the PODS through kubectl
> kubectl exec -it <port-name> -- bash



Show both of the pod and service together
> kubectl get pods, svc

to kick up the system, you can
1. run individual pod files + individual service files
2. run individual deployment files + individual service files
